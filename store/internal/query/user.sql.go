// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: user.sql

package query

import (
	"context"

	uuid "github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOAuth = `-- name: CreateOAuth :exec
INSERT INTO auth.oauth (id, open_id, access_token, refresh_token, allow_sync, valid_until)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateOAuthParams struct {
	ID           uuid.UUID
	OpenID       string
	AccessToken  string
	RefreshToken pgtype.Text
	AllowSync    bool
	ValidUntil   pgtype.Timestamptz
}

func (q *Queries) CreateOAuth(ctx context.Context, arg CreateOAuthParams) error {
	_, err := q.db.Exec(ctx, createOAuth,
		arg.ID,
		arg.OpenID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.AllowSync,
		arg.ValidUntil,
	)
	return err
}

const createPassword = `-- name: CreatePassword :exec
INSERT INTO auth.password (id, password_hash)
VALUES ($1, $2)
`

type CreatePasswordParams struct {
	ID           uuid.UUID
	PasswordHash string
}

func (q *Queries) CreatePassword(ctx context.Context, arg CreatePasswordParams) error {
	_, err := q.db.Exec(ctx, createPassword, arg.ID, arg.PasswordHash)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO auth."user"(id, email, username)
VALUES ($1, $2, $3)
`

type CreateUserParams struct {
	ID       uuid.UUID
	Email    string
	Username string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser, arg.ID, arg.Email, arg.Username)
	return err
}

const findOAuth = `-- name: FindOAuth :one
SELECT id, open_id
FROM auth.oauth
WHERE open_id = $1
`

type FindOAuthRow struct {
	ID     uuid.UUID
	OpenID string
}

func (q *Queries) FindOAuth(ctx context.Context, openID string) (FindOAuthRow, error) {
	row := q.db.QueryRow(ctx, findOAuth, openID)
	var i FindOAuthRow
	err := row.Scan(&i.ID, &i.OpenID)
	return i, err
}

const findUser = `-- name: FindUser :one
SELECT u.id AS id, u.email AS email, p.password_hash AS password_hash
FROM auth."user" AS u
         INNER JOIN auth.password AS p ON u.id = p.id
WHERE email = $1
`

type FindUserRow struct {
	ID           uuid.UUID
	Email        string
	PasswordHash string
}

func (q *Queries) FindUser(ctx context.Context, email string) (FindUserRow, error) {
	row := q.db.QueryRow(ctx, findUser, email)
	var i FindUserRow
	err := row.Scan(&i.ID, &i.Email, &i.PasswordHash)
	return i, err
}

const getAllOAuthUserIds = `-- name: GetAllOAuthUserIds :many
SELECT id
FROM auth.oauth
WHERE deleted_at IS NULL
`

func (q *Queries) GetAllOAuthUserIds(ctx context.Context) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getAllOAuthUserIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, email, username
FROM auth."user"
WHERE id = $1
`

type GetUserRow struct {
	ID       uuid.UUID
	Email    string
	Username string
}

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i GetUserRow
	err := row.Scan(&i.ID, &i.Email, &i.Username)
	return i, err
}

const getUserOAuthToken = `-- name: GetUserOAuthToken :one
SELECT id, open_id, access_token, refresh_token, valid_until
FROM auth.oauth
WHERE id = $1
`

type GetUserOAuthTokenRow struct {
	ID           uuid.UUID
	OpenID       string
	AccessToken  string
	RefreshToken pgtype.Text
	ValidUntil   pgtype.Timestamptz
}

func (q *Queries) GetUserOAuthToken(ctx context.Context, id uuid.UUID) (GetUserOAuthTokenRow, error) {
	row := q.db.QueryRow(ctx, getUserOAuthToken, id)
	var i GetUserOAuthTokenRow
	err := row.Scan(
		&i.ID,
		&i.OpenID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ValidUntil,
	)
	return i, err
}

const getUserPassword = `-- name: GetUserPassword :one
SELECT id, password_hash
FROM auth.password
WHERE id = $1
`

type GetUserPasswordRow struct {
	ID           uuid.UUID
	PasswordHash string
}

func (q *Queries) GetUserPassword(ctx context.Context, id uuid.UUID) (GetUserPasswordRow, error) {
	row := q.db.QueryRow(ctx, getUserPassword, id)
	var i GetUserPasswordRow
	err := row.Scan(&i.ID, &i.PasswordHash)
	return i, err
}

const updateOAuthToken = `-- name: UpdateOAuthToken :exec
UPDATE auth.oauth
SET access_token  = COALESCE($2, access_token),
    refresh_token = COALESCE($3, refresh_token),
    valid_until   = COALESCE($4, valid_until),
    allow_sync    = COALESCE($5, allow_sync),
    updated_at    = NOW()
WHERE id = $1
`

type UpdateOAuthTokenParams struct {
	ID          uuid.UUID
	UAccess     pgtype.Text
	URefresh    pgtype.Text
	UValidUntil pgtype.Timestamptz
	UAllowSync  pgtype.Bool
}

func (q *Queries) UpdateOAuthToken(ctx context.Context, arg UpdateOAuthTokenParams) error {
	_, err := q.db.Exec(ctx, updateOAuthToken,
		arg.ID,
		arg.UAccess,
		arg.URefresh,
		arg.UValidUntil,
		arg.UAllowSync,
	)
	return err
}
