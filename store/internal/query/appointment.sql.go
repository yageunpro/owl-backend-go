// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: appointment.sql

package query

import (
	"context"

	uuid "github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const confirmAppointment = `-- name: ConfirmAppointment :exec
UPDATE appointment.appointment
SET confirm_time = $3,
    status       = 'CONFIRM',
    updated_at   = NOW()
WHERE id = $1
  AND organizer_id = $2
  AND confirm_time IS NULL
`

type ConfirmAppointmentParams struct {
	ID          uuid.UUID
	OrganizerID uuid.UUID
	ConfirmTime pgtype.Timestamptz
}

func (q *Queries) ConfirmAppointment(ctx context.Context, arg ConfirmAppointmentParams) error {
	_, err := q.db.Exec(ctx, confirmAppointment, arg.ID, arg.OrganizerID, arg.ConfirmTime)
	return err
}

const createAppointment = `-- name: CreateAppointment :exec
INSERT INTO appointment.appointment (id, organizer_id, title, description, category, location_id, deadline)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateAppointmentParams struct {
	ID          uuid.UUID
	OrganizerID uuid.UUID
	Title       string
	Description string
	Category    []string
	LocationID  uuid.NullUUID
	Deadline    pgtype.Timestamptz
}

func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) error {
	_, err := q.db.Exec(ctx, createAppointment,
		arg.ID,
		arg.OrganizerID,
		arg.Title,
		arg.Description,
		arg.Category,
		arg.LocationID,
		arg.Deadline,
	)
	return err
}

const createParticipant = `-- name: CreateParticipant :exec
INSERT INTO appointment.participant(id, appointment_id, user_id)
VALUES ($1, $2, $3)
`

type CreateParticipantParams struct {
	ID            uuid.UUID
	AppointmentID uuid.UUID
	UserID        uuid.UUID
}

func (q *Queries) CreateParticipant(ctx context.Context, arg CreateParticipantParams) error {
	_, err := q.db.Exec(ctx, createParticipant, arg.ID, arg.AppointmentID, arg.UserID)
	return err
}

const deleteAppointment = `-- name: DeleteAppointment :exec
UPDATE appointment.appointment
SET deleted_at = NOW(),
    status     = 'DELETE'
WHERE id = $1
  AND organizer_id = $2
`

type DeleteAppointmentParams struct {
	ID          uuid.UUID
	OrganizerID uuid.UUID
}

func (q *Queries) DeleteAppointment(ctx context.Context, arg DeleteAppointmentParams) error {
	_, err := q.db.Exec(ctx, deleteAppointment, arg.ID, arg.OrganizerID)
	return err
}

const getAppointment = `-- name: GetAppointment :one
SELECT id,
       organizer_id,
       status,
       title,
       description,
       category,
       location_id,
       deadline,
       confirm_time,
       deleted_at
FROM appointment.appointment
WHERE id = $1
`

type GetAppointmentRow struct {
	ID          uuid.UUID
	OrganizerID uuid.UUID
	Status      AppointmentStatus
	Title       string
	Description string
	Category    []string
	LocationID  uuid.NullUUID
	Deadline    pgtype.Timestamptz
	ConfirmTime pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
}

func (q *Queries) GetAppointment(ctx context.Context, id uuid.UUID) (GetAppointmentRow, error) {
	row := q.db.QueryRow(ctx, getAppointment, id)
	var i GetAppointmentRow
	err := row.Scan(
		&i.ID,
		&i.OrganizerID,
		&i.Status,
		&i.Title,
		&i.Description,
		&i.Category,
		&i.LocationID,
		&i.Deadline,
		&i.ConfirmTime,
		&i.DeletedAt,
	)
	return i, err
}

const getConfirmAppointment = `-- name: GetConfirmAppointment :many
WITH ap_with_count AS (SELECT a.id           AS id,
                              a.organizer_id AS organizer_id,
                              a.status       AS status,
                              a.title        AS title,
                              a.location_id  AS location_id,
                              a.confirm_time AS confirm_time,
                              a.created_at   AS created_at,
                              a.deleted_at   AS deleted_at,
                              COUNT(p.id)    AS head_count
                       FROM appointment.appointment AS a
                                INNER JOIN appointment.participant p ON a.id = p.appointment_id
                       GROUP BY a.id)
SELECT a.id           AS id,
       a.organizer_id AS organizer_id,
       a.status       AS status,
       a.title        AS title,
       a.location_id  AS location_id,
       a.confirm_time AS confirm_time,
       a.deleted_at   AS deleted_at,
       a.head_count   AS head_count
FROM (SELECT appointment_id AS id
      FROM appointment.participant AS t
      WHERE t.user_id = $1) AS ids
         INNER JOIN ap_with_count AS a ON ids.id = a.id
WHERE status = 'CONFIRM'
ORDER BY a.confirm_time
OFFSET $2 LIMIT $3
`

type GetConfirmAppointmentParams struct {
	UserID uuid.UUID
	Offset int32
	Limit  int32
}

type GetConfirmAppointmentRow struct {
	ID          uuid.UUID
	OrganizerID uuid.UUID
	Status      AppointmentStatus
	Title       string
	LocationID  uuid.NullUUID
	ConfirmTime pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	HeadCount   int64
}

func (q *Queries) GetConfirmAppointment(ctx context.Context, arg GetConfirmAppointmentParams) ([]GetConfirmAppointmentRow, error) {
	rows, err := q.db.Query(ctx, getConfirmAppointment, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConfirmAppointmentRow
	for rows.Next() {
		var i GetConfirmAppointmentRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizerID,
			&i.Status,
			&i.Title,
			&i.LocationID,
			&i.ConfirmTime,
			&i.DeletedAt,
			&i.HeadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDoneAppointment = `-- name: GetDoneAppointment :many
WITH ap_with_count AS (SELECT a.id           AS id,
                              a.organizer_id AS organizer_id,
                              a.status       AS status,
                              a.title        AS title,
                              a.location_id  AS location_id,
                              a.confirm_time AS confirm_time,
                              a.created_at   AS created_at,
                              a.deleted_at   AS deleted_at,
                              COUNT(p.id)    AS head_count
                       FROM appointment.appointment AS a
                                INNER JOIN appointment.participant p ON a.id = p.appointment_id
                       GROUP BY a.id)
SELECT a.id           AS id,
       a.organizer_id AS organizer_id,
       a.status       AS status,
       a.title        AS title,
       a.location_id  AS location_id,
       a.confirm_time AS confirm_time,
       a.deleted_at   AS deleted_at,
       a.head_count   AS head_count
FROM (SELECT appointment_id AS id
      FROM appointment.participant AS t
      WHERE t.user_id = $1) AS ids
         INNER JOIN ap_with_count AS a ON ids.id = a.id
WHERE status = 'DONE'
ORDER BY a.confirm_time DESC
OFFSET $2 LIMIT $3
`

type GetDoneAppointmentParams struct {
	UserID uuid.UUID
	Offset int32
	Limit  int32
}

type GetDoneAppointmentRow struct {
	ID          uuid.UUID
	OrganizerID uuid.UUID
	Status      AppointmentStatus
	Title       string
	LocationID  uuid.NullUUID
	ConfirmTime pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	HeadCount   int64
}

func (q *Queries) GetDoneAppointment(ctx context.Context, arg GetDoneAppointmentParams) ([]GetDoneAppointmentRow, error) {
	rows, err := q.db.Query(ctx, getDoneAppointment, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDoneAppointmentRow
	for rows.Next() {
		var i GetDoneAppointmentRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizerID,
			&i.Status,
			&i.Title,
			&i.LocationID,
			&i.ConfirmTime,
			&i.DeletedAt,
			&i.HeadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParticipants = `-- name: GetParticipants :many
SELECT u.id       AS user_id,
       u.username AS username
FROM appointment.participant AS p
         INNER JOIN auth.user AS u ON p.user_id = u.id
WHERE appointment_id = $1
`

type GetParticipantsRow struct {
	UserID   uuid.UUID
	Username string
}

func (q *Queries) GetParticipants(ctx context.Context, appointmentID uuid.UUID) ([]GetParticipantsRow, error) {
	rows, err := q.db.Query(ctx, getParticipants, appointmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetParticipantsRow
	for rows.Next() {
		var i GetParticipantsRow
		if err := rows.Scan(&i.UserID, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatusAppointment = `-- name: GetStatusAppointment :many
WITH ap_with_count AS (SELECT a.id           AS id,
                              a.organizer_id AS organizer_id,
                              a.status       AS status,
                              a.title        AS title,
                              a.location_id  AS location_id,
                              a.confirm_time AS confirm_time,
                              a.created_at   AS created_at,
                              a.deleted_at   AS deleted_at,
                              COUNT(p.id)    AS head_count
                       FROM appointment.appointment AS a
                                INNER JOIN appointment.participant p ON a.id = p.appointment_id
                       GROUP BY a.id)
SELECT a.id           AS id,
       a.organizer_id AS organizer_id,
       a.status       AS status,
       a.title        AS title,
       a.location_id  AS location_id,
       a.confirm_time AS confirm_time,
       a.deleted_at   AS deleted_at,
       a.head_count   AS head_count
FROM (SELECT appointment_id AS id
      FROM appointment.participant AS t
      WHERE t.user_id = $1) AS ids
         INNER JOIN ap_with_count AS a ON ids.id = a.id
WHERE status = $2
ORDER BY a.created_at DESC
OFFSET $3 LIMIT $4
`

type GetStatusAppointmentParams struct {
	UserID uuid.UUID
	Status AppointmentStatus
	Offset int32
	Limit  int32
}

type GetStatusAppointmentRow struct {
	ID          uuid.UUID
	OrganizerID uuid.UUID
	Status      AppointmentStatus
	Title       string
	LocationID  uuid.NullUUID
	ConfirmTime pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	HeadCount   int64
}

func (q *Queries) GetStatusAppointment(ctx context.Context, arg GetStatusAppointmentParams) ([]GetStatusAppointmentRow, error) {
	rows, err := q.db.Query(ctx, getStatusAppointment,
		arg.UserID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStatusAppointmentRow
	for rows.Next() {
		var i GetStatusAppointmentRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizerID,
			&i.Status,
			&i.Title,
			&i.LocationID,
			&i.ConfirmTime,
			&i.DeletedAt,
			&i.HeadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAppointment = `-- name: UpdateAppointment :exec
UPDATE appointment.appointment
SET title       = COALESCE($3, title),
    description = COALESCE($4, description),
    location_id = COALESCE($5, location_id),
    category    = COALESCE($6, category),
    updated_at  = NOW()
WHERE id = $1
  AND organizer_id = $2
`

type UpdateAppointmentParams struct {
	ID          uuid.UUID
	OrganizerID uuid.UUID
	UTitle      pgtype.Text
	UDesc       pgtype.Text
	ULocationID uuid.NullUUID
	UCategory   []string
}

func (q *Queries) UpdateAppointment(ctx context.Context, arg UpdateAppointmentParams) error {
	_, err := q.db.Exec(ctx, updateAppointment,
		arg.ID,
		arg.OrganizerID,
		arg.UTitle,
		arg.UDesc,
		arg.ULocationID,
		arg.UCategory,
	)
	return err
}
